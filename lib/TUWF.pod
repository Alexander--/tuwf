=head1 NAME

TUWF - The Ultimate Website Framework

=head1 DESCRIPTION

TUWF is a (relatively) small framework designed for writing websites. It
provides an abstraction layer to various environment-specific tasks and has
common functions to ease the creation of both small and large websites.

=head2 Introduction

I<Not sure whether this section is really useful...>

TUWF is slightly different from other website frameworks in various aspects. To
get used to writing websites in TUWF it is important to understand what TUWF
is, and more importantly, what it is not. The following sections explain some
of basic the design principles and philosophies.

=head3 TUWF is for programmers

Something I've learned after several years of developing websites is that there
are two kinds of people involved in the programming aspect of web development:
You have web developers and programmers. Web developers are the kind of people
who just like to get things done, and have less interest in technical
correctness, performance, code-reuse and other such strange concepts.
Programmers, on the other hand, may have experience with writing other forms of
software and realize the importance of maintainable code. They are thus willing
to invest some extra time in doing things right the first time in order to
write code that keeps being fun to maintain, even after a year of active
development.

TUWF - being rather unorthodox among the website frameworks - was written for
the latter group. If you consider yourself a true C<web developer> - someone
who wants to see results without investing too much time, you're probably
better off using one of the more orthodox frameworks such as L<Catalyst|Catalyst> or
L<CGI::Application|CGI::Application>.

=head3 XML is not for humans

XML (and with that, HTML) was designed to be readable and writable by both
machine and human. In reality it's not; writing XML is a huge pain, especially
if you want it to be generated dynamically. This, however, doesn't change the
fact that you really can't build a website without some form of XML. In order
to ease the generation of XML, TUWF comes with an XML generator that combines the
interfaces of L<XML::Writer> and L<XML::Generator> modules, enabling developers to
write XML at ease from within several different subroutines without having to
care about their return value.

=head3 ...and more

This section isn't finished yet.



=head2 General structure of a TUWF website

A website written using TUWF consists of a single Perl script, optionally
accompanied by several modules. The script is responsible for loading,
initializing and running TUWF, and can be used as a CGI or FastCGI script. For
small and simple websites, this script may contain the code for the entire
website. Usually, however, the actual implementation of the website is spread
among the various modules.

The script can load the modules by calling C<TUWF::load()> or
C<TUWF::load_recursive()>. TUWF configuration variables can be set using
C<TUWF::set()>, and URIs can be mapped to functions using C<TUWF::register()>.
These functions can also be called by the loaded modules. In fact, for larger
websites it is common for the script to only initialize TUWF and load the
modules, while all calls to C<TUWF::register()> are done from the modules.

I<TODO: explain callback-based style>

I<TODO: explain TUWF::Object>


=head2 Loading TUWF

I<TODO: Explain the import arguments to 'use TUWF'>



=head1 GLOBAL FUNCTIONS

The main TUWF namespace contains several functions used to initialize the
framework and register the callbacks for your website.

=head2 TUWF::load(@modules)

Loads the listed module names and imports their exported functions to the
C<TUWF::Object> namespace. The modules must be available in any subdirectory in
C<@INC>.

  # make sure the website modules are available from @INC
  use lib 'mylib';

  # load mylib/MyWebsite/HomePage.pm
  TUWF::load('MyWebsite::HomePage');

  # load two other modules
  TUWF::load('MyWebsite::Forum', 'MyUtilities');

Note that your modules must be proper Perl modules. That is, they should return
a true value (usually done by adding C<1;> to the end of the file) and they
should have the correct namespace definition.

=head2 TUWF::load_recursive(@modules)

Works the same as C<TUWF::load()>, but this also loads all submodules.

  # the following will load MyWebsite.pm (if it exists) and all modules below
  # the MyWebsite/ directory (if any).
  TUWF::load_recursive('MyWebsite');

Note that all submodules must be in the same parent directory in C<@INC>.

=head2 TUWF::register(regex => subroutine, ..)

Maps a URI to a function. The I<regex> is matched to L<reqPath()|TUWF::Request>
and must match the path from the begin to the end.  (That is, the regex is used
between C<^> and C<$> marks). Since C<reqPath()> does not contain a leading
C</> character, these should also be omitted in the regexes. It is common to
use the C<qr{}> operator to quote the regex, which prevents you from having to
escape slashes in the path as would be required with C<qr//>.

All registered regexes are matched against any incoming URI, and the subroutine
corresponding to the first matched regex will be called to handle the request.
The first argument to the subroutine will be the main TUWF object. If the
regular expression has capture buffers, these will also be provided as
additional arguments.

  TUWF::register(
    # empty regex = root URI (/)
    # myhomepage() will be called with the main TUWF object
    qr{}  => \&myhomepage,

    # The following will match on any /user/<numeric-id> URI.
    # userpage() will be called with
    # - the TUWF object and
    # - the id-part of the URI ($1 in the regular expression)
    qr{user/(\d+)} => \&userpage,
  );

=head2 TUWF::set(key => value, ..)

Set TUWF configuration variables. I<TODO: document these.>

=head2 TUWF::run()

After TUWF has been initialized, all modules have been loaded and all URIs have
been registered, the last thing that remains is to execute C<TUWF::run()>. This
function will start processing requests and calls the appropriate callbacks at
the appropriate stages.

Whether this function ever returns or not depends on the environment your
script is running in; if you're running your script in a CGI environment,
C<TUWF::run()> will return as soon as the request has been processed. If, on
the other hand, you are running the script as a FastCGI script, it will keep
waiting for new incoming requests and will therefore never return. It is a bad
idea to assume either way, so you want to avoid putting any run-time code after
calling C<TUWF::run()>.


=head1 BASIC METHODS

I<TODO: Reference documentation on some basic object methods>


=head1 FEATURES AND LIMITATIONS

TUWF may be The Ultimate Website Framework, but it is not the perfect solution
to every problem. This section aims to document some of the limitations you may
stumble upon. Note, however, that most of these limitations are considered
features, and will as such not be "fixed".

=over

=item One (sub)domain is one website.

TUWF assumes that the website you are working on resides directly under a
(sub)domain. That is, the homepage of your website has a URI like
I<http://example.com/>, and all sub-pages are directly beneath it. (e.g.
I<http://example.com/about> would be your "about" page).

While it B<is> possible to run a TUWF website in a subdirectory (i.e. the
homepage of the site would be I<http://example.com/mysite/>), you will have to
prefix all HTML links and registered URIs with the name of the subdirectory.
This is neither productive, nor will it be fun when you wish to rename that
directory later on.

=item One website is one (sub)domain.

In the same way as the previous point, TUWF is not made to handle websites that
span multiple (sub)domains and have different behaviour for each one. It is
possible - quite simple, even - to have a different subdomain affect some
configuration parameter while keeping the structure and behaviour of the
website the same as for the other domains. An example of this could be a
language setting embedded in a subdomain: I<en.example.com> could show to the
English version of your site, while I<de.example.com> will have the German
translation.

Things will become messy as soon as you want (sub)domains to behave
differently. If you want I<forum.example.com> to host a forum and
I<wiki.example.com> to be a wiki, you will want to avoid programming both
subdomains in the same TUWF script. A common solution is to write a separate
script for each subdomain. It is still possible to share code among both sites
by means of modules.

=item The generated response is buffered.

This means that you can't use TUWF for applications that require streaming
dynamic content (e.g. a chat application), and you may get into memory issues
when sending large files.

On the other hand, this does allow you to change the response completely while
generating an other one, which is extremely useful if your code decides to
throw an error while a part of the response has already been generated. In such
a case your visitor will properly see your error page and not some messed up
page that does not make sense. Thanks to this buffering, you will also be able
to set cookies and send other headers B<after> generating the contents of the
page.  And as an added bonus, your pages will be compressed more efficiently
when output compression is enabled.

=item Everything is UTF-8

All TUWF functions (with some exceptions) will only accept and return Unicode
strings in Perls native encoding. All incoming data is assumed to be encoded in
UTF-8 and all outgoing data will be encoded in UTF-8. This is generally what
you want when developing new applications. If, for some very strange reason,
you want all I/O with the browser to be in anything other than UTF-8, you won't
be able to use TUWF. It B<is> possible to use external resources which use
other encodings, but you will have to C<decode()> that into Perls native
encoding before giving it to any TUWF function.


=back




=head1 COPYRIGHT

Copyright (c) 2008-2011 Yoran Heling.

This framework is free software available under the liberal MIT license. See
the COPYING file in the distribution for the details.



=head1 AUTHOR

Yoran Heling <projects@yorhel.nl>

=cut

